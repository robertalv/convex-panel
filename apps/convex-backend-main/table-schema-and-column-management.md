# Table Schema and Column Management in Convex Dashboard

## How the Table Gets Schema for Columns

### 1. Schema Sources

The table component gets column schema information from multiple sources:

```typescript
// From Table.tsx - Schema is passed as a prop
export function Table({
  activeSchema,        // Current deployed schema
  columns = [],        // Generated columns from data
  // ... other props
}: {
  activeSchema: SchemaJson | null;
  // ...
})
```

### 2. Schema Resolution Process

```typescript
// The schema comes from the deployment context
const { useCurrentDeployment } = useContext(DeploymentInfoContext);
const deployment = useCurrentDeployment();

// Schema is fetched via system queries like:
// "_system/cli/listSchemas" - Gets all schemas
// "_system/frontend/common:getTableSchema" - Gets specific table schema
```

### 3. Column Generation from Schema

The columns are generated by combining:

1. **Schema Definition**: Field types and validation rules
2. **Data Inspection**: Actual data types from existing documents
3. **System Fields**: `_id`, `_creationTime` (always present)

```typescript
// Column structure matches this interface
interface Column<GenericDocument> {
  Header: string;           // Column display name
  accessor?: string;        // Field path (e.g., "user.name")
  id: string;              // Unique column identifier
  width?: number;          // Column width
  Cell?: ComponentType;    // Custom cell renderer
}
```

### 4. Schema-to-Column Mapping

```typescript
// Pseudo-code for how schema becomes columns
function generateColumnsFromSchema(schema: SchemaJson, tableName: string) {
  const tableSchema = schema.tables[tableName];
  const columns = [];
  
  // Add selection column first
  columns.push({
    Header: "*select",
    id: "select",
    width: 50
  });
  
  // Add schema-defined fields
  Object.entries(tableSchema.fields).forEach(([fieldName, fieldSchema]) => {
    columns.push({
      Header: fieldName,
      accessor: fieldName,
      id: fieldName,
      type: fieldSchema.type,        // "string", "number", "id", etc.
      optional: fieldSchema.optional,
      // Custom cell renderer based on type
      Cell: getCellRendererForType(fieldSchema.type)
    });
  });
  
  // Always add system fields
  columns.push(
    { Header: "_id", accessor: "_id", id: "_id" },
    { Header: "_creationTime", accessor: "_creationTime", id: "_creationTime" }
  );
  
  return columns;
}
```

## Column Re-arrangement System

### 1. Drag and Drop Implementation

The table uses `@dnd-kit` for column reordering:

```typescript
// From Table.tsx - DnD Context setup
<DndContext
  sensors={sensors}
  collisionDetection={closestCenter}
  onDragStart={handleDragStart}
  onDragMove={handleDragMove}
  onDragEnd={handleDragEnd}
  onDragCancel={handleDragCancel}
>
  <SortableContext
    items={state.columnOrder}
    strategy={horizontalListSortingStrategy}
  >
    {/* Table content */}
  </SortableContext>
</DndContext>
```

### 2. Column Order State Management

```typescript
// Column order is managed by react-table
const {
  state,           // Contains columnOrder array
  setColumnOrder,  // Function to update order
} = useTable(
  {
    columns: visibleColumns,
    data,
    initialState: {
      columnOrder: [
        "*select",  // Selection column always first
        ...(storedColumnOrder || orderableColumnNames),
      ],
    },
    stateReducer: (newState, action) => {
      if (action.type === "setColumnOrder") {
        // Filter out *select when storing the column order
        const newOrder = newState.columnOrder.filter(
          (col) => col !== "*select",
        );
        setStoredColumnOrder(newOrder);
        // Notify parent component of the change
        onColumnOrderChange?.(newOrder);
      }
      return newState;
    },
  },
  useBlockLayout,
  useColumnOrder,    // Enables column reordering
  useResizeColumns,  // Enables column resizing
);
```

### 3. Persistent Column Order Storage

```typescript
// From useStoredColumnOrder hook
const [storedColumnOrder, setStoredColumnOrder] = useStoredColumnOrder(localStorageKey);

// Stored in localStorage with key like: "table_order_messages"
// Format: ["body", "user", "channel", "_creationTime"]
```

### 4. Column Reordering Logic

```typescript
// From Table.tsx - reorderColumns function
const reorderColumns = useCallback(
  (item: { index: number }, newIndex: number) => {
    const { index: currentIndex } = item;
    const currentItem = state.columnOrder[currentIndex];

    // Create new order array
    const newColumnOrder = [...state.columnOrder];
    newColumnOrder.splice(currentIndex, 1);      // Remove from current position
    newColumnOrder.splice(newIndex, 0, currentItem); // Insert at new position

    // Ensure *select always stays at the beginning
    const filtered = newColumnOrder.filter((col) => col !== "*select");
    setColumnOrder(["*select", ...filtered]);
  },
  [setColumnOrder, state.columnOrder],
);
```

### 5. Column Header Drag Implementation

```typescript
// From ColumnHeader.tsx - Each column header is draggable
export function ColumnHeader({ column, columnIndex, ... }) {
  const canDragOrDrop = columnIndex !== 0 && !isResizingColumn; // Can't drag select column
  
  const { attributes, listeners, setNodeRef, isDragging, isOver } = useSortable({
    id: column.id,
    disabled: !canDragOrDrop,
  });

  return (
    <div
      ref={setNodeRef}
      {...attributes}
      {...listeners}
      className={cn(
        "column-header",
        isDragging && "opacity-50",
        isOver && "bg-accent"
      )}
    >
      {/* Column content */}
    </div>
  );
}
```

### 6. Visual Drag Feedback

```typescript
// From Table.tsx - Drag overlay for visual feedback
{activeColumn && activeColumnPosition !== null && (() => {
  const columnWidth = activeColumn.getHeaderProps().style?.width;
  const parsedWidth = typeof columnWidth === "string" 
    ? parseFloat(columnWidth) 
    : typeof columnWidth === "number" ? columnWidth : 0;

  const containerWidth = tableContainerRef.current?.offsetWidth || 0;
  const scrollLeft = tableContainerRef.current?.scrollLeft || 0;

  // Adjust for horizontal scroll and clamp position
  const unclamped = activeColumnPosition + dragOffset - scrollLeft;
  const left = Math.max(0, Math.min(unclamped, containerWidth - parsedWidth));

  return (
    <div
      className="pointer-events-none absolute top-0 rounded border border-border-selected bg-background-primary/50 shadow-lg"
      style={{
        left,
        width: columnWidth,
        height: tableContainerRef.current?.offsetHeight || "100%",
      }}
    />
  );
})()}
```

## Column Management Features

### 1. Hidden Columns Support

```typescript
// Columns can be hidden via hiddenColumns prop
const visibleColumns = useMemo(
  () =>
    columns.filter(
      (c) =>
        c.Header === "*select" || !hiddenColumns.includes(c.Header as string),
    ),
  [columns, hiddenColumns],
);
```

### 2. Column Width Persistence

```typescript
// From useTrackColumnWidths hook
const resetColumnWidths = useTrackColumnWidths(state, localStorageKey);

// Widths stored in localStorage with key like: "table_widths_messages"
// Format: { "body": 200, "user": 150, "_creationTime": 180 }
```

### 3. Dynamic Column Updates

```typescript
// From trackDataColumnChanges function
function trackDataColumnChanges(
  columns: string[],
  storedColumnOrder: string[] | undefined,
  updateColumnOrder: (newOrder: string[]) => void,
) {
  if (!storedColumnOrder) return;

  // Find new columns not in stored order
  const newColumns = columns
    .filter((c) => !storedColumnOrder.includes(c))
    .sort((a, b) => a.localeCompare(b)); // Sort alphabetically

  const existingColumns = storedColumnOrder.filter((c) => columns.includes(c));

  // No changes needed
  if (newColumns.length === 0 && existingColumns.length === storedColumnOrder.length) {
    return;
  }

  // Handle _creationTime special case (should be last)
  const lastColumn = existingColumns[existingColumns.length - 1];
  const newOrder = lastColumn === "_creationTime"
    ? [
        ...existingColumns.filter((c) => c !== "_creationTime"),
        ...newColumns,
        "_creationTime",
      ]
    : [...existingColumns, ...newColumns];

  updateColumnOrder(["*select", ...newOrder]);
}
```

### 4. Context Menu Column Operations

```typescript
// From TableContextMenu - Reset columns option
<ContextMenuItem
  onClick={() => {
    setColumnOrder(["*select", ...orderableColumnNames]);
    setStoredColumnOrder(orderableColumnNames);
    resetColumnWidths();
  }}
>
  Reset Columns
</ContextMenuItem>
```

## Schema Integration Points

### 1. Cell Rendering Based on Schema

```typescript
// Different cell renderers based on field type
const getCellRendererForType = (fieldType: string) => {
  switch (fieldType) {
    case 'id':
      return IdCell;           // Renders as clickable ID
    case 'string':
      return StringCell;       // Editable text input
    case 'number':
      return NumberCell;       // Numeric input
    case 'boolean':
      return BooleanCell;      // Checkbox
    case 'array':
      return ArrayCell;        // JSON array display
    case 'object':
      return ObjectCell;       // Nested object display
    default:
      return DefaultCell;
  }
};
```

### 2. Validation Based on Schema

```typescript
// Schema provides validation rules for editing
const validateFieldValue = (value: any, fieldSchema: FieldSchema) => {
  if (fieldSchema.optional && (value === null || value === undefined)) {
    return true;
  }
  
  switch (fieldSchema.type) {
    case 'string':
      return typeof value === 'string';
    case 'number':
      return typeof value === 'number' && !isNaN(value);
    case 'boolean':
      return typeof value === 'boolean';
    case 'id':
      return typeof value === 'string' && value.startsWith('j');
    default:
      return true;
  }
};
```

### 3. Schema-Aware Filtering

```typescript
// Filters are generated based on schema types
const generateFiltersForField = (fieldName: string, fieldSchema: FieldSchema) => {
  const baseFilters = ['equals', 'not equals'];
  
  switch (fieldSchema.type) {
    case 'string':
      return [...baseFilters, 'contains', 'starts with', 'ends with'];
    case 'number':
      return [...baseFilters, 'greater than', 'less than', 'between'];
    case 'boolean':
      return ['is true', 'is false'];
    case 'id':
      return [...baseFilters, 'exists', 'does not exist'];
    default:
      return baseFilters;
  }
};
```

## Key Takeaways

1. **Schema Source**: Comes from `activeSchema` prop, fetched via system queries
2. **Column Generation**: Schema fields + system fields + data inspection
3. **Drag & Drop**: Uses `@dnd-kit` with `SortableContext` and `useSortable`
4. **Persistence**: Column order and widths stored in localStorage
5. **Dynamic Updates**: Handles schema changes and new columns automatically
6. **Visual Feedback**: Drag overlay shows column being moved
7. **Constraints**: Selection column always first, some columns can't be dragged
8. **Integration**: Schema types determine cell renderers and validation rules

The system is designed to be flexible and handle schema evolution while maintaining user preferences for column arrangement and sizing.